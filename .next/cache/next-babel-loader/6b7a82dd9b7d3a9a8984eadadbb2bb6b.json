{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _nodeHtmlParser = require(\"node-html-parser\");\n\nvar _constants = require(\"./constants\");\n\nconst MIDDLEWARE_TIME_BUDGET = 10;\nconst middlewareRegistry = [];\n\nfunction registerPostProcessor(name, middleware, condition) {\n  middlewareRegistry.push({\n    name,\n    middleware,\n    condition: condition || null\n  });\n}\n\nasync function processHTML(html, data, options) {\n  // Don't parse unless there's at least one processor middleware\n  if (!middlewareRegistry[0]) {\n    return html;\n  }\n\n  const postProcessData = {\n    preloads: {\n      images: []\n    }\n  };\n  const root = (0, _nodeHtmlParser.parse)(html);\n  let document = html; // Calls the middleware, with some instrumentation and logging\n\n  async function callMiddleWare(middleware, name) {\n    let timer = Date.now();\n    middleware.inspect(root, postProcessData, data);\n    const inspectTime = Date.now() - timer;\n    document = await middleware.mutate(document, postProcessData, data);\n    timer = Date.now() - timer;\n\n    if (timer > MIDDLEWARE_TIME_BUDGET) {\n      console.warn(`The postprocess middleware \"${name}\" took ${timer}ms(${inspectTime}, ${timer - inspectTime}) to complete. This is longer than the ${MIDDLEWARE_TIME_BUDGET} limit.`);\n    }\n\n    return;\n  }\n\n  for (let i = 0; i < middlewareRegistry.length; i++) {\n    let middleware = middlewareRegistry[i];\n\n    if (!middleware.condition || middleware.condition(options)) {\n      await callMiddleWare(middlewareRegistry[i].middleware, middlewareRegistry[i].name);\n    }\n  }\n\n  return document;\n}\n\nclass FontOptimizerMiddleware {\n  constructor() {\n    this.fontDefinitions = [];\n\n    this.mutate = async (markup, _data, options) => {\n      let result = markup;\n\n      if (!options.getFontDefinition) {\n        return markup;\n      }\n\n      for (const key in this.fontDefinitions) {\n        const url = this.fontDefinitions[key];\n\n        if (result.indexOf(`<style data-href=\"${url}\">`) > -1) {\n          // The font is already optimized and probably the response is cached\n          continue;\n        }\n\n        const fontContent = options.getFontDefinition(url);\n        result = result.replace('</head>', `<style data-href=\"${url}\">${fontContent.replace(/(\\n|\\s)/g, '')}</style></head>`);\n      }\n\n      return result;\n    };\n  }\n\n  inspect(originalDom, _data, options) {\n    if (!options.getFontDefinition) {\n      return;\n    } // collecting all the requested font definitions\n\n\n    originalDom.querySelectorAll('link').filter(tag => tag.getAttribute('rel') === 'stylesheet' && tag.hasAttribute('data-href') && _constants.OPTIMIZED_FONT_PROVIDERS.some(url => tag.getAttribute('data-href').startsWith(url))).forEach(element => {\n      const url = element.getAttribute('data-href');\n      this.fontDefinitions.push(url);\n    });\n  }\n\n} // Initialization\n\n\nregisterPostProcessor('Inline-Fonts', new FontOptimizerMiddleware(), // Using process.env because passing Experimental flag through loader is not possible.\n// @ts-ignore\noptions => options.optimizeFonts || process.env.__NEXT_OPTIMIZE_FONTS);\nvar _default = processHTML;\nexports.default = _default;","map":null,"metadata":{},"sourceType":"script"}